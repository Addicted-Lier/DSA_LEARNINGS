| Feature  | set           | map          | unordered_set | unordered_map |
| -------- | ------------- | ------------ | ------------- | ------------- |
| Order    | Sorted        | Sorted       | No            | No            |
| Unique   | Yes           | Keys         | Yes           | Keys          |
| Lookup   | log N         | log N        | O(1)          | O(1)          |
| Min/Max  | Yes           | Yes          | No            | No            |
| Use case | unique sorted | freq + order | fast check    | fast freq     |


â“ Need order or min/max? â†’ set / map
â“ Just fast lookup/frequency? â†’ unordered_*

HASHING

The Idea Behind Hashing (Core Intuition)
Hashing = Direct access
Instead of searching, we jump directly to where the value should be.
Real-life analogy:
Phonebook
Roll number â†’ student
Word â†’ dictionary meaning
ğŸ‘‰ Key â†’ Location

The Hash Table (Buckets)

A hash table is just:
an array of buckets
each bucket stores elements mapped by hash

The BIG Problem â€” Collisions âš ï¸

What if:
ğŸ’¥ Collision (same index)
21 % 10 = 1
31 % 10 = 1

Solution: Chaining
Each bucket stores a list.

bucket[1] â†’ [21, 31]
C++ does this internally for you.